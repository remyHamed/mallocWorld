function heightmapDiamondSquare(MAP_SIZE: number, // taille de la grille à générer, de valeur (2^n)+1
                                wrap: boolean,    // true pour les cartes répétables, false sinon
                                roughness: number // intensité de l'élévation supplémentaire aléatoire
                               ): number[][] {

  var map = [];
  var nw = (wrap ? 0 : 1); // indicateur non répétable

  // Crée un tableau 2D vide, size × size
  for (var i = 0; i < MAP_SIZE; i++) {
    map[i] = [];
  }

  // Initialise les coins de la carte
  map[0][0] = Math.round(Math.random() * 255); // haut gauche
  map[0][MAP_SIZE - 1] = Math.round(Math.random()* 255); // bas gauche
  map[MAP_SIZE - 1][0] = Math.round(Math.random() * 255); // haut droite
  map[MAP_SIZE - 1][MAP_SIZE - 1] = Math.round(Math.random() * 255); // bas droite

  var h = 128; // la plage (-h -> +h) pour le décalage moyen

  // sideLength est la longueur d'un côté d'un carré
  // ou la longueur de la diagonale d'un losange
  for (var sideLength = MAP_SIZE - 1;
    // sideLength doit être >= 2 afin de toujours avoir
    // une nouvelle valeur (si c'est 1, on écrase les valeurs existantes
    // de la précédente itération)
    sideLength >= 2;
    // à chaque itération, on considère les carrés ou les losanges
    // les plus petits, et on diminue la variation du décalage
    sideLength /= 2, h /= 2.0) {
    // la moitié de la longueur d'un carré
    // ou la distance du centre d'un losange à un coin
    // (juste pour rendre les calculs ci-dessous un peu plus clairs)
    var halfSide = sideLength / 2;

    // génère les nouvelles valeurs du carré
    for (var x = 0; x < MAP_SIZE - 1; x += sideLength) {
      for (var y = 0; y < MAP_SIZE - 1; y += sideLength) {
        // x, y est en haut à gauche du carré
        // calcule la moyenne des coins existants
        var avg = map[x][y] + //top left
          map[x + sideLength][y] + // top right
          map[x][y + sideLength] + // lower left
          map[x + sideLength][y + sideLength]; // lower right
        avg /= 4.0;

        // le centre c'est la moyenne plus un décalage aléatoire
        map[x + halfSide][y + halfSide] = normalize(avg + offset(h, roughness));
      } // for y
    } // for x

    // génère les valeurs du losange
    // puisque les losanges sont en quinconce on se déplace en x
    // uniquement de halfSide.
    // NOTE : si la carte ne doit pas se répéter, alors x < MAP_SIZE
    // pour générer les valeurs du bord
    for (var x = 0; x < MAP_SIZE - 1 + nw; x += halfSide) {
      // et y est x décalé de halfSide, mais translaté
      // de la pleine longueur du côté
      // NOTE : si la carte ne doit pas se répéter, alors y < MAP_SIZE
      // pour générer les valeurs du bord
      for (var y = (x + halfSide) % sideLength; y < MAP_SIZE - 1 + nw; y += sideLength) {
        // x, y est le centre du losange
        // à noter que nous devons utiliser le modulo et l'ajout de MAP_SIZE pour la soustraction
        // de façon à parcourir cycliquement le tableau pour trouver les coins
        var avg =
          map[(x - halfSide + MAP_SIZE - 1) % (MAP_SIZE - 1)][y] + // gauche du centre
          map[(x + halfSide) % (MAP_SIZE - 1)][y] + // droite du centre
          map[x][(y + halfSide) % (MAP_SIZE - 1)] + // bas du centre
          map[x][(y - halfSide + MAP_SIZE - 1) % (MAP_SIZE - 1)]; // haut du centre

        avg /= 4.0;

        // nouvelle valeur = moyenne + décalage aléatoire
        avg = normalize(avg + offset(h, roughness));
        // met à jour la valeur pour le centre du losange
        map[x][y] = avg;

        // duplique les valeurs sur les bords si carte répétable
        if (wrap) {
          if (x == 0) map[MAP_SIZE - 1][y] = avg;
          if (y == 0) map[x][MAP_SIZE - 1] = avg;
        }
      } // for y
    } // for x
  } // for sideLength

  return map;
} // heightmapDiamondSquare

// Renvoie un décalage aléatoire proportionnel à la hauteur
function offset(height, roughness) {
  // On calcule la valeur aléatoire dans une plage de 2h
  // et ensuite on soustrait h de façon à ce que la valeur finale
  // soit dans l'intervalle [-h, +h]
  return (Math.random() * 2 - 1) * height * roughness;
} // offset

// Normalise la valeur pour s'assurer qu'elle reste dans les limites
function normalize(value) {
  return Math.round(Math.max(Math.min(value, 255), 0));
} // normalize
